{"ast":null,"code":"import _slicedToArray from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _toConsumableArray from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/data/shared/repos/biomuta/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"index\", \"length\", \"match\", \"valid\", \"void\"],\n  _excluded2 = [\"attributes\", \"className\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"];\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inherits(StyleFilter, _Filter);\n  var _super = _createSuper(StyleFilter);\n  function StyleFilter() {\n    _classCallCheck(this, StyleFilter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(StyleFilter, [{\n    key: \"attribute\",\n    value: function attribute(name, value) {\n      if (name === 'style') {\n        Object.keys(value).forEach(function (key) {\n          if (String(value[key]).match(INVALID_STYLES)) {\n            // eslint-disable-next-line no-param-reassign\n            delete value[key];\n          }\n        });\n      } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n      return value;\n    }\n  }]);\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n  return document.implementation.createHTMLDocument('Interweave');\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    _classCallCheck(this, Parser);\n    var _props$allowList;\n    _defineProperty(this, \"allowed\", void 0);\n    _defineProperty(this, \"banned\", void 0);\n    _defineProperty(this, \"blocked\", void 0);\n    _defineProperty(this, \"container\", void 0);\n    _defineProperty(this, \"content\", []);\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"matchers\", void 0);\n    _defineProperty(this, \"filters\", void 0);\n    _defineProperty(this, \"keyIndex\", void 0);\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(_toConsumableArray(filters), [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n  _createClass(Parser, [{\n    key: \"applyAttributeFilters\",\n    value: function applyAttributeFilters(name, value) {\n      return this.filters.reduce(function (nextValue, filter) {\n        return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n      }, value);\n    }\n    /**\n     * Loop through and apply all registered node filters.\n     */\n  }, {\n    key: \"applyNodeFilters\",\n    value: function applyNodeFilters(name, node) {\n      // Allow null to be returned\n      return this.filters.reduce(function (nextNode, filter) {\n        return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n      }, node);\n    }\n    /**\n     * Loop through and apply all registered matchers to the string.\n     * If a match is found, create a React element, and build a new array.\n     * This array allows React to interpolate and render accordingly.\n     */\n  }, {\n    key: \"applyMatchers\",\n    value: function applyMatchers(string, parentConfig) {\n      var _this = this;\n      var elements = {};\n      var props = this.props;\n      var matchedString = string;\n      var elementIndex = 0;\n      var parts = null;\n      this.matchers.forEach(function (matcher) {\n        var tagName = matcher.asTag().toLowerCase();\n        var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n        if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n          return;\n        } // Skip matchers in which the child cannot be rendered\n\n        if (!_this.canRenderChild(parentConfig, config)) {\n          return;\n        } // Continuously trigger the matcher until no matches are found\n\n        var tokenizedString = '';\n        while (matchedString && (parts = matcher.match(matchedString))) {\n          var _parts = parts,\n            index = _parts.index,\n            length = _parts.length,\n            match = _parts.match,\n            valid = _parts.valid,\n            isVoid = _parts.void,\n            partProps = _objectWithoutProperties(_parts, _excluded);\n          var tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n          if (index > 0) {\n            tokenizedString += matchedString.slice(0, index);\n          }\n          if (valid) {\n            tokenizedString += isVoid ? \"{{{\".concat(tokenName, \"/}}}\") : \"{{{\".concat(tokenName, \"}}}\").concat(match, \"{{{/\").concat(tokenName, \"}}}\");\n            _this.keyIndex += 1;\n            elementIndex += 1;\n            elements[tokenName] = {\n              children: match,\n              matcher: matcher,\n              props: _objectSpread(_objectSpread(_objectSpread({}, props), partProps), {}, {\n                key: _this.keyIndex\n              })\n            };\n          } else {\n            tokenizedString += match;\n          } // Reduce the string being matched against,\n          // otherwise we end up in an infinite loop!\n\n          if (matcher.greedy) {\n            matchedString = tokenizedString + matchedString.slice(index + length);\n            tokenizedString = '';\n          } else {\n            // eslint-disable-next-line unicorn/explicit-length-check\n            matchedString = matchedString.slice(index + (length || match.length));\n          }\n        } // Update the matched string with the tokenized string,\n        // so that the next matcher can apply to it.\n\n        if (!matcher.greedy) {\n          matchedString = tokenizedString + matchedString;\n        }\n      });\n      if (elementIndex === 0) {\n        return string;\n      }\n      return this.replaceTokens(matchedString, elements);\n    }\n    /**\n     * Determine whether the child can be rendered within the parent.\n     */\n  }, {\n    key: \"canRenderChild\",\n    value: function canRenderChild(parentConfig, childConfig) {\n      if (!parentConfig.tagName || !childConfig.tagName) {\n        return false;\n      } // No children\n\n      if (parentConfig.void) {\n        return false;\n      } // Valid children\n\n      if (parentConfig.children.length > 0) {\n        return parentConfig.children.includes(childConfig.tagName);\n      }\n      if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n        return false;\n      } // Valid parent\n\n      if (childConfig.parent.length > 0) {\n        return childConfig.parent.includes(parentConfig.tagName);\n      } // Self nesting\n\n      if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n        return false;\n      } // Content category type\n\n      return Boolean(parentConfig && parentConfig.content & childConfig.type);\n    }\n    /**\n     * Convert line breaks in a string to HTML `<br/>` tags.\n     * If the string contains HTML, we should not convert anything,\n     * as line breaks should be handled by `<br/>`s in the markup itself.\n     */\n  }, {\n    key: \"convertLineBreaks\",\n    value: function convertLineBreaks(markup) {\n      var _this$props = this.props,\n        noHtml = _this$props.noHtml,\n        disableLineBreaks = _this$props.disableLineBreaks;\n      if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n        return markup;\n      } // Replace carriage returns\n\n      var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n      nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n      nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n      return nextMarkup;\n    }\n    /**\n     * Create a detached HTML document that allows for easy HTML\n     * parsing while not triggering scripts or loading external\n     * resources.\n     */\n  }, {\n    key: \"createContainer\",\n    value: function createContainer(markup) {\n      var _this$props$container;\n      var factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n      var doc = factory();\n      if (!doc) {\n        return undefined;\n      }\n      var tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n      var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n      if (markup.match(INVALID_ROOTS)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          throw new Error('HTML documents as Interweave content are not supported.');\n        }\n      } else {\n        el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n      }\n      return el;\n    }\n    /**\n     * Convert an elements attribute map to an object map.\n     * Returns null if no attributes are defined.\n     */\n  }, {\n    key: \"extractAttributes\",\n    value: function extractAttributes(node) {\n      var _this2 = this;\n      var allowAttributes = this.props.allowAttributes;\n      var attributes = {};\n      var count = 0;\n      if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n        return null;\n      } // @ts-expect-error Cant type iterator\n\n      _toConsumableArray(node.attributes).forEach(function (attr) {\n        var name = attr.name,\n          value = attr.value;\n        var newName = name.toLowerCase();\n        var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n        if (!_this2.isSafe(node)) {\n          return;\n        } // Do not allow denied attributes, excluding ARIA attributes\n        // Do not allow events or XSS injections\n\n        if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n          return;\n        } // Apply attribute filters\n\n        var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n        if (filter === FILTER_CAST_BOOL) {\n          newValue = true; // Cast to number\n        } else if (filter === FILTER_CAST_NUMBER) {\n          newValue = Number.parseFloat(String(newValue)); // Cast to string\n        } else if (filter !== FILTER_NO_CAST) {\n          newValue = String(newValue);\n        }\n        attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n        count += 1;\n      });\n      if (count === 0) {\n        return null;\n      }\n      return attributes;\n    }\n    /**\n     * Extract the style attribute as an object and remove values that allow for attack vectors.\n     */\n  }, {\n    key: \"extractStyleAttribute\",\n    value: function extractStyleAttribute(node) {\n      var styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n      Array.from(node.style).forEach(function (key) {\n        var value = node.style[key];\n        if (typeof value === 'string' || typeof value === 'number') {\n          styles[key.replace(/-([a-z])/g, function (match, letter) {\n            return String(letter).toUpperCase();\n          })] = value;\n        }\n      });\n      return styles;\n    }\n    /**\n     * Return configuration for a specific tag.\n     */\n  }, {\n    key: \"getTagConfig\",\n    value: function getTagConfig(tagName) {\n      var common = {\n        children: [],\n        content: 0,\n        invalid: [],\n        parent: [],\n        self: true,\n        tagName: '',\n        type: 0,\n        void: false\n      }; // Only spread when a tag config exists,\n      // otherwise we use the empty `tagName`\n      // for parent config inheritance.\n\n      if (TAGS[tagName]) {\n        return _objectSpread(_objectSpread(_objectSpread({}, common), TAGS[tagName]), {}, {\n          tagName: tagName\n        });\n      }\n      return common;\n    }\n    /**\n     * Verify that a node is safe from XSS and injection attacks.\n     */\n  }, {\n    key: \"isSafe\",\n    value: function isSafe(node) {\n      // URLs should only support HTTP, email and phone numbers\n      if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n        var href = node.getAttribute('href'); // Fragment protocols start with about:\n        // So let's just allow them\n\n        if (href !== null && href !== void 0 && href.startsWith('#')) {\n          return true;\n        }\n        var protocol = node.protocol.toLowerCase();\n        return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n      }\n      return true;\n    }\n    /**\n     * Verify that an HTML tag is allowed to render.\n     */\n  }, {\n    key: \"isTagAllowed\",\n    value: function isTagAllowed(tagName) {\n      if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n        return false;\n      } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n      return this.props.allowElements || this.allowed.has(tagName);\n    }\n    /**\n     * Parse the markup by injecting it into a detached document,\n     * while looping over all child nodes and generating an\n     * array to interpolate into JSX.\n     */\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      if (!this.container) {\n        return [];\n      }\n      return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n    }\n    /**\n     * Loop over the nodes children and generate a\n     * list of text nodes and React elements.\n     */\n  }, {\n    key: \"parseNode\",\n    value: function parseNode(parentNode, parentConfig) {\n      var _this3 = this;\n      var _this$props2 = this.props,\n        noHtml = _this$props2.noHtml,\n        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n        allowElements = _this$props2.allowElements,\n        transform = _this$props2.transform,\n        transformOnlyAllowList = _this$props2.transformOnlyAllowList;\n      var content = [];\n      var mergedText = ''; // @ts-expect-error Cant type iterator\n\n      _toConsumableArray(parentNode.childNodes).forEach(function (node) {\n        // Create React elements from HTML elements\n        if (node.nodeType === ELEMENT_NODE) {\n          var tagName = node.nodeName.toLowerCase();\n          var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n          if (mergedText) {\n            content.push(mergedText);\n            mergedText = '';\n          } // Apply node filters first\n\n          var nextNode = _this3.applyNodeFilters(tagName, node);\n          if (!nextNode) {\n            return;\n          } // Apply transformation second\n\n          var children;\n          if (transform && !(transformOnlyAllowList && !_this3.isTagAllowed(tagName))) {\n            _this3.keyIndex += 1;\n            var key = _this3.keyIndex; // Must occur after key is set\n\n            children = _this3.parseNode(nextNode, config);\n            var transformed = transform(nextNode, children, config);\n            if (transformed === null) {\n              return;\n            }\n            if (typeof transformed !== 'undefined') {\n              content.push( /*#__PURE__*/React.cloneElement(transformed, {\n                key: key\n              }));\n              return;\n            } // Reset as we're not using the transformation\n\n            _this3.keyIndex = key - 1;\n          } // Never allow these tags (except via a transformer)\n\n          if (_this3.banned.has(tagName)) {\n            return;\n          } // Only render when the following criteria is met:\n          //  - HTML has not been disabled\n          //  - Tag is allowed\n          //  - Child is valid within the parent\n\n          if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n            var _children;\n            _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n            var attributes = _this3.extractAttributes(nextNode);\n            var elementProps = {\n              tagName: tagName\n            };\n            if (attributes) {\n              elementProps.attributes = attributes;\n            }\n            if (config.void) {\n              elementProps.selfClose = config.void;\n            }\n            content.push( /*#__PURE__*/React.createElement(Element, _objectSpread(_objectSpread({}, elementProps), {}, {\n              key: _this3.keyIndex\n            }), (_children = children) !== null && _children !== void 0 ? _children : _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n            // Important: If the current element is not allowed,\n            // use the parent element for the next scope.\n          } else {\n            content = [].concat(_toConsumableArray(content), _toConsumableArray(_this3.parseNode(nextNode, config.tagName ? config : parentConfig)));\n          } // Apply matchers if a text node\n        } else if (node.nodeType === TEXT_NODE) {\n          var text = noHtml && !noHtmlExceptMatchers ? node.textContent :\n          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n          _this3.applyMatchers(node.textContent || '', parentConfig);\n          if (Array.isArray(text)) {\n            content = [].concat(_toConsumableArray(content), _toConsumableArray(text));\n          } else {\n            mergedText += text;\n          }\n        }\n      });\n      if (mergedText) {\n        content.push(mergedText);\n      }\n      return content;\n    }\n    /**\n     * Deconstruct the string into an array, by replacing custom tokens with React elements,\n     * so that React can render it correctly.\n     */\n  }, {\n    key: \"replaceTokens\",\n    value: function replaceTokens(tokenizedString, elements) {\n      if (!tokenizedString.includes('{{{')) {\n        return tokenizedString;\n      }\n      var nodes = [];\n      var text = tokenizedString;\n      var open = null; // Find an open token tag\n\n      while (open = text.match(OPEN_TOKEN)) {\n        var _open = open,\n          _open2 = _slicedToArray(_open, 2),\n          match = _open2[0],\n          tokenName = _open2[1];\n        var startIndex = open.index;\n        var isVoid = match.includes('/');\n        if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n          throw new Error(\"Token \\\"\".concat(tokenName, \"\\\" found but no matching element to replace with.\"));\n        } // Extract the previous non-token text\n\n        if (startIndex > 0) {\n          nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n          text = text.slice(startIndex);\n        }\n        var _elements$tokenName = elements[tokenName],\n          children = _elements$tokenName.children,\n          matcher = _elements$tokenName.matcher,\n          elementProps = _elements$tokenName.props;\n        var endIndex = void 0; // Use tag as-is if void\n\n        if (isVoid) {\n          endIndex = match.length;\n          nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n        } else {\n          var close = text.match(new RegExp(\"{{{/\".concat(tokenName, \"}}}\")));\n          if (process.env.NODE_ENV !== \"production\" && !close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\".concat(tokenName, \"\\\".\"));\n          }\n          endIndex = close.index + close[0].length;\n          nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n        } // Reduce text for the next interation\n\n        text = text.slice(endIndex);\n      } // Extra the remaining text\n\n      if (text.length > 0) {\n        nodes.push(text);\n      } // Reduce to a string if possible\n\n      if (nodes.length === 0) {\n        return '';\n      }\n      if (nodes.length === 1 && typeof nodes[0] === 'string') {\n        return nodes[0];\n      }\n      return nodes;\n    }\n  }]);\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\nfunction Markup(props) {\n  var _ref;\n  var attributes = props.attributes,\n    className = props.className,\n    containerTagName = props.containerTagName,\n    content = props.content,\n    emptyContent = props.emptyContent,\n    parsedContent = props.parsedContent,\n    tagName = props.tagName,\n    baseNoWrap = props.noWrap;\n  var tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  var noWrap = tag === 'fragment' ? true : baseNoWrap;\n  var mainContent;\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n    className = props.className,\n    _props$content = props.content,\n    content = _props$content === void 0 ? '' : _props$content,\n    _props$disableFilters = props.disableFilters,\n    disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n    _props$disableMatcher = props.disableMatchers,\n    disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n    _props$emptyContent = props.emptyContent,\n    emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n    _props$filters = props.filters,\n    filters = _props$filters === void 0 ? [] : _props$filters,\n    _props$matchers = props.matchers,\n    matchers = _props$matchers === void 0 ? [] : _props$matchers,\n    _props$onAfterParse = props.onAfterParse,\n    onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n    _props$onBeforeParse = props.onBeforeParse,\n    onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n    _props$tagName = props.tagName,\n    tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n    _props$noWrap = props.noWrap,\n    noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n    parserProps = _objectWithoutProperties(props, _excluded2);\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\nexport { Interweave, Markup, Parser };","map":{"version":3,"names":["StyleFilter","_Filter","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","attribute","name","Object","keys","forEach","String","match","INVALID_STYLES","Filter","ELEMENT_NODE","TEXT_NODE","INVALID_ROOTS","ALLOWED_ATTRS","createDocument","window","document","undefined","implementation","createHTMLDocument","Parser","markup","props","length","matchers","filters","_props$allowList","_defineProperty","process","env","NODE_ENV","TypeError","keyIndex","container","createContainer","allowed","Set","allowList","ALLOWED_TAG_LIST","banned","BANNED_TAG_LIST","blocked","blockList","applyAttributeFilters","reduce","nextValue","filter","applyNodeFilters","node","nextNode","elements","elementIndex","parts","matcher","_this","canRenderChild","parentConfig","config","tokenizedString","matchedString","_parts","index","valid","isVoid","void","partProps","_objectWithoutProperties","_excluded","tokenName","propName","slice","concat","_objectSpread","greedy","string","childConfig","tagName","children","invalid","includes","parent","self","Boolean","content","type","convertLineBreaks","noHtml","_this$props","disableLineBreaks","nextMarkup","replace","_this$props$container","factory","global","INTERWEAVE_SSR_POLYFILL","doc","tag","containerTagName","el","body","createElement","innerHTML","escapeHtml","extractAttributes","_this2","allowAttributes","attributes","count","nodeType","ATTRIBUTES","newName","isSafe","FILTER_DENY","startsWith","FILTER_CAST_BOOL","newValue","Number","parseFloat","FILTER_NO_CAST","extractStyleAttribute","styles","style","letter","toUpperCase","common","TAGS","HTMLAnchorElement","href","getAttribute","protocol","toLowerCase","parse","parseNode","getTagConfig","nodeName","parentNode","_this3","_this$props2","allowElements","transform","transformOnlyAllowList","mergedText","isTagAllowed","transformed","push","React","cloneElement","has","noHtmlExceptMatchers","_children","elementProps","Element","_toConsumableArray","text","textContent","applyMatchers","Array","isArray","replaceTokens","nodes","open","_open","_open2","_slicedToArray","startIndex","Error","_elements$tokenName","endIndex","close","RegExp","Markup","mainContent","_ref","className","parsedContent","baseNoWrap","noWrap","emptyContent","Fragment","Interweave","_props$content","_props$disableFilters","disableFilters","_props$disableMatcher","_props$emptyContent","_props$filters","_props$matchers","_props$onAfterParse","onAfterParse","_props$onBeforeParse","_props$tagName","_props$noWrap","_excluded2","allMatchers","disableMatchers","allFilters","afterCallbacks","onBeforeParse","bind","beforeCallbacks","callback","nextString","parser","parserProps","parserNodes"],"sources":["/data/shared/repos/biomuta/app/node_modules/interweave/src/StyleFilter.ts","/data/shared/repos/biomuta/app/node_modules/interweave/src/Parser.ts","/data/shared/repos/biomuta/app/node_modules/interweave/src/Markup.tsx","/data/shared/repos/biomuta/app/node_modules/interweave/src/Interweave.tsx"],"sourcesContent":["import { Filter } from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport class StyleFilter extends Filter {\n\toverride attribute<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\tif (name === 'style') {\n\t\t\tObject.keys(value).forEach((key) => {\n\t\t\t\tif (String(value[key]).match(INVALID_STYLES)) {\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\tdelete value[key];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn value;\n\t}\n}\n","/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n\tALLOWED_TAG_LIST,\n\tATTRIBUTES,\n\tATTRIBUTES_TO_PROPS,\n\tBANNED_TAG_LIST,\n\tFILTER_CAST_BOOL,\n\tFILTER_CAST_NUMBER,\n\tFILTER_DENY,\n\tFILTER_NO_CAST,\n\tTAGS,\n} from './constants';\nimport { Element } from './Element';\nimport { StyleFilter } from './StyleFilter';\nimport {\n\tAttributes,\n\tAttributeValue,\n\tChildrenNode,\n\tElementAttributes,\n\tElementProps,\n\tFilterInterface,\n\tMatcherElementsMap,\n\tMatcherInterface,\n\tNode,\n\tNodeConfig,\n\tParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n\t// Maybe SSR? Just do nothing instead of crashing!\n\tif (typeof window === 'undefined' || typeof document === 'undefined') {\n\t\treturn undefined;\n\t}\n\n\treturn document.implementation.createHTMLDocument('Interweave');\n}\n\nexport class Parser {\n\tallowed: Set<string>;\n\n\tbanned: Set<string>;\n\n\tblocked: Set<string>;\n\n\tcontainer?: HTMLElement;\n\n\tcontent: Node[] = [];\n\n\tprops: ParserProps;\n\n\tmatchers: MatcherInterface[];\n\n\tfilters: FilterInterface[];\n\n\tkeyIndex: number;\n\n\tconstructor(\n\t\tmarkup: string,\n\t\tprops: ParserProps = {},\n\t\tmatchers: MatcherInterface[] = [],\n\t\tfilters: FilterInterface[] = [],\n\t) {\n\t\tif (__DEV__ && markup && typeof markup !== 'string') {\n\t\t\tthrow new TypeError('Interweave parser requires a valid string.');\n\t\t}\n\n\t\tthis.props = props;\n\t\tthis.matchers = matchers;\n\t\tthis.filters = [...filters, new StyleFilter()];\n\t\tthis.keyIndex = -1;\n\t\tthis.container = this.createContainer(markup || '');\n\t\tthis.allowed = new Set(props.allowList ?? ALLOWED_TAG_LIST);\n\t\tthis.banned = new Set(BANNED_TAG_LIST);\n\t\tthis.blocked = new Set(props.blockList);\n\t}\n\n\t/**\n\t * Loop through and apply all registered attribute filters.\n\t */\n\tapplyAttributeFilters<K extends keyof ElementAttributes>(\n\t\tname: K,\n\t\tvalue: ElementAttributes[K],\n\t): ElementAttributes[K] {\n\t\treturn this.filters.reduce(\n\t\t\t(nextValue, filter) =>\n\t\t\t\tnextValue !== null && typeof filter.attribute === 'function'\n\t\t\t\t\t? filter.attribute(name, nextValue)\n\t\t\t\t\t: nextValue,\n\t\t\tvalue,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered node filters.\n\t */\n\tapplyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n\t\t// Allow null to be returned\n\t\treturn this.filters.reduce(\n\t\t\t(nextNode, filter) =>\n\t\t\t\tnextNode !== null && typeof filter.node === 'function'\n\t\t\t\t\t? filter.node(name, nextNode)\n\t\t\t\t\t: nextNode,\n\t\t\tnode,\n\t\t);\n\t}\n\n\t/**\n\t * Loop through and apply all registered matchers to the string.\n\t * If a match is found, create a React element, and build a new array.\n\t * This array allows React to interpolate and render accordingly.\n\t */\n\tapplyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n\t\tconst elements: MatcherElementsMap = {};\n\t\tconst { props } = this;\n\t\tlet matchedString = string;\n\t\tlet elementIndex = 0;\n\t\tlet parts = null;\n\n\t\tthis.matchers.forEach((matcher) => {\n\t\t\tconst tagName = matcher.asTag().toLowerCase();\n\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t// Skip matchers that have been disabled from props or are not supported\n\t\t\tif ((props as Record<string, unknown>)[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip matchers in which the child cannot be rendered\n\t\t\tif (!this.canRenderChild(parentConfig, config)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Continuously trigger the matcher until no matches are found\n\t\t\tlet tokenizedString = '';\n\n\t\t\twhile (matchedString && (parts = matcher.match(matchedString))) {\n\t\t\t\tconst { index, length, match, valid, void: isVoid, ...partProps } = parts;\n\t\t\t\tconst tokenName = matcher.propName + String(elementIndex);\n\n\t\t\t\t// Piece together a new string with interpolated tokens\n\t\t\t\tif (index > 0) {\n\t\t\t\t\ttokenizedString += matchedString.slice(0, index);\n\t\t\t\t}\n\n\t\t\t\tif (valid) {\n\t\t\t\t\ttokenizedString += isVoid\n\t\t\t\t\t\t? `{{{${tokenName}/}}}`\n\t\t\t\t\t\t: `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\telementIndex += 1;\n\t\t\t\t\telements[tokenName] = {\n\t\t\t\t\t\tchildren: match,\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t...props,\n\t\t\t\t\t\t\t...partProps,\n\t\t\t\t\t\t\tkey: this.keyIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttokenizedString += match;\n\t\t\t\t}\n\n\t\t\t\t// Reduce the string being matched against,\n\t\t\t\t// otherwise we end up in an infinite loop!\n\t\t\t\tif (matcher.greedy) {\n\t\t\t\t\tmatchedString = tokenizedString + matchedString.slice(index + length);\n\t\t\t\t\ttokenizedString = '';\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line unicorn/explicit-length-check\n\t\t\t\t\tmatchedString = matchedString.slice(index + (length || match.length));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update the matched string with the tokenized string,\n\t\t\t// so that the next matcher can apply to it.\n\t\t\tif (!matcher.greedy) {\n\t\t\t\tmatchedString = tokenizedString + matchedString;\n\t\t\t}\n\t\t});\n\n\t\tif (elementIndex === 0) {\n\t\t\treturn string;\n\t\t}\n\n\t\treturn this.replaceTokens(matchedString, elements);\n\t}\n\n\t/**\n\t * Determine whether the child can be rendered within the parent.\n\t */\n\tcanRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n\t\tif (!parentConfig.tagName || !childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// No children\n\t\tif (parentConfig.void) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid children\n\t\tif (parentConfig.children.length > 0) {\n\t\t\treturn parentConfig.children.includes(childConfig.tagName);\n\t\t}\n\n\t\tif (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Valid parent\n\t\tif (childConfig.parent.length > 0) {\n\t\t\treturn childConfig.parent.includes(parentConfig.tagName);\n\t\t}\n\n\t\t// Self nesting\n\t\tif (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Content category type\n\t\treturn Boolean(parentConfig && parentConfig.content & childConfig.type);\n\t}\n\n\t/**\n\t * Convert line breaks in a string to HTML `<br/>` tags.\n\t * If the string contains HTML, we should not convert anything,\n\t * as line breaks should be handled by `<br/>`s in the markup itself.\n\t */\n\tconvertLineBreaks(markup: string): string {\n\t\tconst { noHtml, disableLineBreaks } = this.props;\n\n\t\tif (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n\t\t\treturn markup;\n\t\t}\n\n\t\t// Replace carriage returns\n\t\tlet nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n\t\t// Replace long line feeds\n\t\tnextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n\t\t// Replace line feeds with `<br/>`s\n\t\tnextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n\t\treturn nextMarkup;\n\t}\n\n\t/**\n\t * Create a detached HTML document that allows for easy HTML\n\t * parsing while not triggering scripts or loading external\n\t * resources.\n\t */\n\tcreateContainer(markup: string): HTMLElement | undefined {\n\t\tconst factory =\n\t\t\t(typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n\t\tconst doc = factory();\n\n\t\tif (!doc) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst tag = this.props.containerTagName ?? 'body';\n\t\tconst el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n\t\tif (markup.match(INVALID_ROOTS)) {\n\t\t\tif (__DEV__) {\n\t\t\t\tthrow new Error('HTML documents as Interweave content are not supported.');\n\t\t\t}\n\t\t} else {\n\t\t\tel.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n\t\t}\n\n\t\treturn el;\n\t}\n\n\t/**\n\t * Convert an elements attribute map to an object map.\n\t * Returns null if no attributes are defined.\n\t */\n\textractAttributes(node: HTMLElement): Attributes | null {\n\t\tconst { allowAttributes } = this.props;\n\t\tconst attributes: Attributes = {};\n\t\tlet count = 0;\n\n\t\tif (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...node.attributes].forEach((attr: Attr) => {\n\t\t\tconst { name, value } = attr;\n\t\t\tconst newName = name.toLowerCase();\n\t\t\tconst filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n\t\t\t// Verify the node is safe from attacks\n\t\t\tif (!this.isSafe(node)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do not allow denied attributes, excluding ARIA attributes\n\t\t\t// Do not allow events or XSS injections\n\t\t\tif (\n\t\t\t\t!newName.match(ALLOWED_ATTRS) &&\n\t\t\t\t((!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n\t\t\t\t\tnewName.startsWith('on') ||\n\t\t\t\t\tvalue.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Apply attribute filters\n\t\t\tlet newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n\t\t\t// Cast to boolean\n\t\t\tif (filter === FILTER_CAST_BOOL) {\n\t\t\t\tnewValue = true;\n\n\t\t\t\t// Cast to number\n\t\t\t} else if (filter === FILTER_CAST_NUMBER) {\n\t\t\t\tnewValue = Number.parseFloat(String(newValue));\n\n\t\t\t\t// Cast to string\n\t\t\t} else if (filter !== FILTER_NO_CAST) {\n\t\t\t\tnewValue = String(newValue);\n\t\t\t}\n\n\t\t\tattributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n\t\t\t\tnewName as keyof ElementAttributes,\n\t\t\t\tnewValue,\n\t\t\t) as AttributeValue;\n\t\t\tcount += 1;\n\t\t});\n\n\t\tif (count === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * Extract the style attribute as an object and remove values that allow for attack vectors.\n\t */\n\textractStyleAttribute(node: HTMLElement): object {\n\t\tconst styles: Record<string, number | string> = {};\n\n\t\t// eslint-disable-next-line unicorn/prefer-spread\n\t\tArray.from(node.style).forEach((key) => {\n\t\t\tconst value = node.style[key as keyof CSSStyleDeclaration];\n\n\t\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tstyles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn styles;\n\t}\n\n\t/**\n\t * Return configuration for a specific tag.\n\t */\n\tgetTagConfig(tagName: string): NodeConfig {\n\t\tconst common = {\n\t\t\tchildren: [],\n\t\t\tcontent: 0,\n\t\t\tinvalid: [],\n\t\t\tparent: [],\n\t\t\tself: true,\n\t\t\ttagName: '',\n\t\t\ttype: 0,\n\t\t\tvoid: false,\n\t\t};\n\n\t\t// Only spread when a tag config exists,\n\t\t// otherwise we use the empty `tagName`\n\t\t// for parent config inheritance.\n\t\tif (TAGS[tagName]) {\n\t\t\treturn {\n\t\t\t\t...common,\n\t\t\t\t...TAGS[tagName],\n\t\t\t\ttagName,\n\t\t\t};\n\t\t}\n\n\t\treturn common;\n\t}\n\n\t/**\n\t * Verify that a node is safe from XSS and injection attacks.\n\t */\n\tisSafe(node: HTMLElement): boolean {\n\t\t// URLs should only support HTTP, email and phone numbers\n\t\tif (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n\t\t\tconst href = node.getAttribute('href');\n\n\t\t\t// Fragment protocols start with about:\n\t\t\t// So let's just allow them\n\t\t\tif (href?.startsWith('#')) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst protocol = node.protocol.toLowerCase();\n\n\t\t\treturn (\n\t\t\t\tprotocol === ':' ||\n\t\t\t\tprotocol === 'http:' ||\n\t\t\t\tprotocol === 'https:' ||\n\t\t\t\tprotocol === 'mailto:' ||\n\t\t\t\tprotocol === 'tel:'\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Verify that an HTML tag is allowed to render.\n\t */\n\tisTagAllowed(tagName: string): boolean {\n\t\tif (this.banned.has(tagName) || this.blocked.has(tagName)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\treturn this.props.allowElements || this.allowed.has(tagName);\n\t}\n\n\t/**\n\t * Parse the markup by injecting it into a detached document,\n\t * while looping over all child nodes and generating an\n\t * array to interpolate into JSX.\n\t */\n\tparse(): Node[] {\n\t\tif (!this.container) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n\t}\n\n\t/**\n\t * Loop over the nodes children and generate a\n\t * list of text nodes and React elements.\n\t */\n\tparseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n\t\tconst {\n\t\t\tnoHtml,\n\t\t\tnoHtmlExceptMatchers,\n\t\t\tallowElements,\n\t\t\ttransform,\n\t\t\ttransformOnlyAllowList,\n\t\t} = this.props;\n\t\tlet content: Node[] = [];\n\t\tlet mergedText = '';\n\n\t\t// @ts-expect-error Cant type iterator\n\t\t[...parentNode.childNodes].forEach((node: ChildNode) => {\n\t\t\t// Create React elements from HTML elements\n\t\t\tif (node.nodeType === ELEMENT_NODE) {\n\t\t\t\tconst tagName = node.nodeName.toLowerCase();\n\t\t\t\tconst config = this.getTagConfig(tagName);\n\n\t\t\t\t// Persist any previous text\n\t\t\t\tif (mergedText) {\n\t\t\t\t\tcontent.push(mergedText);\n\t\t\t\t\tmergedText = '';\n\t\t\t\t}\n\n\t\t\t\t// Apply node filters first\n\t\t\t\tconst nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n\t\t\t\tif (!nextNode) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Apply transformation second\n\t\t\t\tlet children;\n\n\t\t\t\tif (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n\t\t\t\t\tthis.keyIndex += 1;\n\t\t\t\t\tconst key = this.keyIndex;\n\n\t\t\t\t\t// Must occur after key is set\n\t\t\t\t\tchildren = this.parseNode(nextNode, config);\n\n\t\t\t\t\tconst transformed = transform(nextNode, children, config);\n\n\t\t\t\t\tif (transformed === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof transformed !== 'undefined') {\n\t\t\t\t\t\tcontent.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset as we're not using the transformation\n\t\t\t\t\tthis.keyIndex = key - 1;\n\t\t\t\t}\n\n\t\t\t\t// Never allow these tags (except via a transformer)\n\t\t\t\tif (this.banned.has(tagName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Only render when the following criteria is met:\n\t\t\t\t//  - HTML has not been disabled\n\t\t\t\t//  - Tag is allowed\n\t\t\t\t//  - Child is valid within the parent\n\t\t\t\tif (\n\t\t\t\t\t!(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n\t\t\t\t\tthis.isTagAllowed(tagName) &&\n\t\t\t\t\t(allowElements || this.canRenderChild(parentConfig, config))\n\t\t\t\t) {\n\t\t\t\t\tthis.keyIndex += 1;\n\n\t\t\t\t\t// Build the props as it makes it easier to test\n\t\t\t\t\tconst attributes = this.extractAttributes(nextNode);\n\t\t\t\t\tconst elementProps: ElementProps = {\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\telementProps.attributes = attributes;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config.void) {\n\t\t\t\t\t\telementProps.selfClose = config.void;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent.push(\n\t\t\t\t\t\tReact.createElement(\n\t\t\t\t\t\t\tElement,\n\t\t\t\t\t\t\t{ ...elementProps, key: this.keyIndex },\n\t\t\t\t\t\t\tchildren ?? this.parseNode(nextNode, config),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\n\t\t\t\t\t// Render the children of the current element only.\n\t\t\t\t\t// Important: If the current element is not allowed,\n\t\t\t\t\t// use the parent element for the next scope.\n\t\t\t\t} else {\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t...content,\n\t\t\t\t\t\t...this.parseNode(nextNode, config.tagName ? config : parentConfig),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Apply matchers if a text node\n\t\t\t} else if (node.nodeType === TEXT_NODE) {\n\t\t\t\tconst text =\n\t\t\t\t\tnoHtml && !noHtmlExceptMatchers\n\t\t\t\t\t\t? node.textContent\n\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\t\t\t\t\t\t  this.applyMatchers(node.textContent || '', parentConfig);\n\n\t\t\t\tif (Array.isArray(text)) {\n\t\t\t\t\tcontent = [...content, ...text];\n\t\t\t\t} else {\n\t\t\t\t\tmergedText += text!;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (mergedText) {\n\t\t\tcontent.push(mergedText);\n\t\t}\n\n\t\treturn content;\n\t}\n\n\t/**\n\t * Deconstruct the string into an array, by replacing custom tokens with React elements,\n\t * so that React can render it correctly.\n\t */\n\treplaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n\t\tif (!tokenizedString.includes('{{{')) {\n\t\t\treturn tokenizedString;\n\t\t}\n\n\t\tconst nodes: Node[] = [];\n\t\tlet text = tokenizedString;\n\t\tlet open: RegExpMatchArray | null = null;\n\n\t\t// Find an open token tag\n\t\twhile ((open = text.match(OPEN_TOKEN))) {\n\t\t\tconst [match, tokenName] = open;\n\t\t\tconst startIndex = open.index!;\n\t\t\tconst isVoid = match.includes('/');\n\n\t\t\tif (__DEV__ && !elements[tokenName]) {\n\t\t\t\tthrow new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n\t\t\t}\n\n\t\t\t// Extract the previous non-token text\n\t\t\tif (startIndex > 0) {\n\t\t\t\tnodes.push(text.slice(0, startIndex));\n\n\t\t\t\t// Reduce text so that the closing tag will be found after the opening\n\t\t\t\ttext = text.slice(startIndex);\n\t\t\t}\n\n\t\t\tconst { children, matcher, props: elementProps } = elements[tokenName];\n\t\t\tlet endIndex: number;\n\n\t\t\t// Use tag as-is if void\n\t\t\tif (isVoid) {\n\t\t\t\tendIndex = match.length;\n\n\t\t\t\tnodes.push(matcher.createElement(children, elementProps));\n\n\t\t\t\t// Find the closing tag if not void\n\t\t\t} else {\n\t\t\t\tconst close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n\t\t\t\tif (__DEV__ && !close) {\n\t\t\t\t\tthrow new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n\t\t\t\t}\n\n\t\t\t\tendIndex = close.index! + close[0].length;\n\n\t\t\t\tnodes.push(\n\t\t\t\t\tmatcher.createElement(\n\t\t\t\t\t\tthis.replaceTokens(text.slice(match.length, close.index), elements),\n\t\t\t\t\t\telementProps,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Reduce text for the next interation\n\t\t\ttext = text.slice(endIndex);\n\t\t}\n\n\t\t// Extra the remaining text\n\t\tif (text.length > 0) {\n\t\t\tnodes.push(text);\n\t\t}\n\n\t\t// Reduce to a string if possible\n\t\tif (nodes.length === 0) {\n\t\t\treturn '';\n\t\t}\n\t\tif (nodes.length === 1 && typeof nodes[0] === 'string') {\n\t\t\treturn nodes[0];\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n","/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport { Element } from './Element';\nimport { Parser } from './Parser';\nimport { MarkupProps } from './types';\n\nexport function Markup(props: MarkupProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontainerTagName,\n\t\tcontent,\n\t\temptyContent,\n\t\tparsedContent,\n\t\ttagName,\n\t\tnoWrap: baseNoWrap,\n\t} = props;\n\tconst tag = containerTagName ?? tagName ?? 'span';\n\tconst noWrap = tag === 'fragment' ? true : baseNoWrap;\n\tlet mainContent;\n\n\tif (parsedContent) {\n\t\tmainContent = parsedContent;\n\t} else {\n\t\tconst markup = new Parser(content ?? '', props).parse();\n\n\t\tif (markup.length > 0) {\n\t\t\tmainContent = markup;\n\t\t}\n\t}\n\n\tif (!mainContent) {\n\t\tmainContent = emptyContent;\n\t}\n\n\tif (noWrap) {\n\t\t// eslint-disable-next-line react/jsx-no-useless-fragment\n\t\treturn <React.Fragment>{mainContent}</React.Fragment>;\n\t}\n\n\treturn (\n\t\t<Element attributes={attributes} className={className} tagName={tag}>\n\t\t\t{mainContent}\n\t\t</Element>\n\t);\n}\n","/* eslint-disable promise/prefer-await-to-callbacks */\nimport React from 'react';\nimport { Markup } from './Markup';\nimport { Parser } from './Parser';\nimport { InterweaveProps } from './types';\n\nexport function Interweave(props: InterweaveProps) {\n\tconst {\n\t\tattributes,\n\t\tclassName,\n\t\tcontent = '',\n\t\tdisableFilters = false,\n\t\tdisableMatchers = false,\n\t\temptyContent = null,\n\t\tfilters = [],\n\t\tmatchers = [],\n\t\tonAfterParse = null,\n\t\tonBeforeParse = null,\n\t\ttagName = 'span',\n\t\tnoWrap = false,\n\t\t...parserProps\n\t} = props;\n\tconst allMatchers = disableMatchers ? [] : matchers;\n\tconst allFilters = disableFilters ? [] : filters;\n\tconst beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n\tconst afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n\t// Inherit callbacks from matchers\n\tallMatchers.forEach((matcher) => {\n\t\tif (matcher.onBeforeParse) {\n\t\t\tbeforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n\t\t}\n\n\t\tif (matcher.onAfterParse) {\n\t\t\tafterCallbacks.push(matcher.onAfterParse.bind(matcher));\n\t\t}\n\t});\n\n\t// Trigger before callbacks\n\tconst markup = beforeCallbacks.reduce((string, callback) => {\n\t\tconst nextString = callback(string, props);\n\n\t\tif (__DEV__ && typeof nextString !== 'string') {\n\t\t\tthrow new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n\t\t}\n\n\t\treturn nextString;\n\t}, content ?? '');\n\n\t// Parse the markup\n\tconst parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n\t// Trigger after callbacks\n\tconst nodes = afterCallbacks.reduce((parserNodes, callback) => {\n\t\tconst nextNodes = callback(parserNodes, props);\n\n\t\tif (__DEV__ && !Array.isArray(nextNodes)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'Interweave `onAfterParse` must return an array of strings and React elements.',\n\t\t\t);\n\t\t}\n\n\t\treturn nextNodes;\n\t}, parser.parse());\n\n\treturn (\n\t\t<Markup\n\t\t\tattributes={attributes}\n\t\t\tclassName={className}\n\t\t\t// eslint-disable-next-line react/destructuring-assignment\n\t\t\tcontainerTagName={props.containerTagName}\n\t\t\temptyContent={emptyContent}\n\t\t\tnoWrap={noWrap}\n\t\t\tparsedContent={nodes.length === 0 ? undefined : nodes}\n\t\t\ttagName={tagName}\n\t\t/>\n\t);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAKaA,WAAN,0BAAAC,OAAA;EAAAC,SAAA,CAAAF,WAAA,EAAAC,OAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,WAAA;EAAA,SAAAA,YAAA;IAAAK,eAAA,OAAAL,WAAA;IAAA,OAAAG,MAAA,CAAAG,KAAA,OAAAC,SAAA;EAAA;EAAAC,YAAA,CAAAR,WAAA;IAAAS,GAAA;IAAAC,KAAA,EACG,SAAAC,UACRC,IADiB,EAEjBF,KAFiB,EAGM;MACvB,IAAIE,IAAI,KAAK,OAAb,EAAsB;QACrBC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,OAAnB,CAA4B,UAAAN,GAAD,EAAS;UACnC,IAAIO,MAAM,CAACN,KAAK,CAACD,GAAD,CAAN,CAAN,CAAmBQ,KAAnB,CAAyBC,cAAzB,CAAJ,EAA8C;YAC7C;YACA,OAAOR,KAAK,CAACD,GAAD,CAAZ;UACA;QACD,CALD;MAMA,CARsB;;MAWvB,OAAOC,KAAP;IACA;EAAA;EAAA,OAAAV,WAAA;AAAA,EAhB+BmB,MAA1B;;AC2BP,IAAMC,YAAY,GAAlB;AACA,IAAMC,SAAA,IAAa;AACnB,IAAMC,aAAa,GAAG,sCAAtB;AACA,IAAMC,aAAa,qDAAnB;;AAGC,SAAAC,eAAA;EACA;EACC,WAAOC,MAAA,KAAP,sBAAAC,QAAA;IACA,OAAAC,SAAA;;EAGD,OAAAD,QAAA,CAAAE,cAAA,CAAAC,kBAAA;;IAGAC,MAAO;EAEP,SAAAA,OAAMC,MAAA;IAAA,IAAAC,KAAA,GAAAzB,SAAA,CAAA0B,MAAA,QAAA1B,SAAA,QAAAoB,SAAA,GAAApB,SAAA;IAAA,IAAA2B,QAAA,GAAA3B,SAAA,CAAA0B,MAAA,QAAA1B,SAAA,QAAAoB,SAAA,GAAApB,SAAA;IAAA,IAAA4B,OAAA,GAAA5B,SAAA,CAAA0B,MAAA,QAAA1B,SAAA,QAAAoB,SAAA,GAAApB,SAAA;IAAAF,eAAA,OAAAyB,MAAA;IAEN,IAAAM,gBAAO;IAIPC,eAAO;IAIPA,eAAQ;IAIRA,eAAQ;IAERA,eACC,CADU,IAEV,aACA,OAA4B,CAAG;IAI9BA,eAAU,OAAU;;IAIrBA,eAAA,CAAgB,gBAAhB;IAEAA,eAAA,CAAgB,IAAhB;IAEAA,eAAe,KAAI,EAAJ,UAAc,OAAN;IAEvB,IAAAC,OAAK,CAALC,GAAe,CAAAC,QAAQ,KAAM,YAA7B,IAAAT,MAAA,WAAAA,MAAA;MACA,UAAAU,SAAA;IAED;IAED,KAAAT,KAAA,GAAAA,KAAA;;;IACC,KAAAU,QAAA;IAIC,KAAAC,SAAY,OAAQ,CAAAC,eACnB,CAAAb,MAAY,IAAZ,EACC;IAKF,KAAAc,OAAA,OAAAC,GAAA,EAAAV,gBAAA,GAAAJ,KAAA,CAAAe,SAAA,cAAAX,gBAAA,cAAAA,gBAAA,GAAAY,gBAAA;IAED,KAAAC,MAAA,OAAAH,GAAA,CAAAI,eAAA;IACD,KAAAC,OAAA,OAAAL,GAAA,CAAAd,KAAA,CAAAoB,SAAA;EACA;;;AACC;;;WASC,SAAAC,sBAAAzC,IAAA,EAAAF,KAAA;MAED,YAAAyB,OAAA,CAAAmB,MAAA,WAAAC,SAAA,EAAAC,MAAA;QAAA,OAAAD,SAAA,oBAAAC,MAAA,CAAA7C,SAAA,kBAAA6C,MAAA,CAAA7C,SAAA,CAAAC,IAAA,EAAA2C,SAAA,IAAAA,SAAA;MAAA,GAAA7C,KAAA;IACD;IACA;AACA;AACA;EAFA;IAAAD,GAAA;IAAAC,KAAA,EAGC,SAAA+C,iBAAc7C,IAAD,EAAiB8C,IAAA;MAC7B;MACA,OAAM,KAAAvB,OAAA,CAAAmB,MAAA,WAAAK,QAAA,EAAAH,MAAA;QAAA,OAAAG,QAAA,oBAAAH,MAAA,CAAAE,IAAA,kBAAAF,MAAA,CAAAE,IAAA,CAAA9C,IAAA,EAAA+C,QAAA,IAAAA,QAAA;MAAA,GAAAD,IAAA;IAAE;IAAF;AACN;AACA;AACA;AAEA;EALM;IAAAjD,GAAA;IAAAC,KAAA,E;;MAUL,IAAKkD,QAAkC,KAAO;MAC7C,IACA5B,KAPiC,G,KAOjCA,KAPiC;;MAUlC,IAAA6B,YAAU;MACT,IAAAC,KAAA;MACA,IAZiC,CAAA5B,QAAA,CAAAnB,OAAA,WAAAgD,OAAA;;;;;UAiBlC;QACC;;QAAuB,KAAAC,KAAjB,CAAAC,cAAA,CAAAC,YAAA,EAAAC,MAAA;UAAwB;QAAO;;QACrC,IAAAC,eAAe,GAAG;QAGlB,OAAIC,aAAW,KAAAP,KAAA,GAAAC,OAAA,CAAA9C,KAAA,CAAAoD,aAAA;UACd,IAAAC,MAAA,GAWAR,KAAA;YAVAS,KAAA,GAAAD,MAAA,CAAAC,KAAA;;YAEDtD,KAAI,GAAAqD,MAAA,CAAJrD,KAAI;YACHuD,KAAA,GAAAF,MAAA,CAAAE,KAAA;YAIKC,MAAA,GAAAH,MAAA,CAALI,IAAA;YAEAC,SAAY,GAAAC,wBAAA,CAAAN,MAAA,EAAAO,SAAA;UAEX,IAAAC,SAAU,GAAAf,OADW,CAAAgB,QAAA,GAAA/D,MAAA,CAAA6C,YAAA;;UAGrB,IAAAU,KAAK,GAAE,CACN;YACAH,eAAG,IAFGC,aAAA,CAAAW,KAAA,IAAAT,KAAA;UAGN;UANoB,IAAtBC,KAAA;YARDJ,eAiBO,IAAAK,MAAA,SAAAQ,MAAA,CAAAH,SAAA,kBAAAG,MAAA,CAAAH,SAAA,SAAAG,MAAA,CAAAhE,KAAA,UAAAgE,MAAA,CAAAH,SAAA;YACNd,KAAA,CAAAtB,QAAA,IAAe;YA3B+CmB,YAAA;YA+B/DD,QAAA,CAAAkB,SAAA;;;cACI9C,KAAA,EAAAkD,aAAA,CAAAA,aAAA,CAAAA,aAAA,KAAQlD,KAAQ,GACnB2C,SAAgB;gBAChBlE,GAAA,EAAAuD,KAAA,CAAAtB;cAAA;YAEA;UACA;YACA0B,eAAA,IAAAnD,KAAA;UAvDgC;UA2DlC;;UACA,IAAK8C,OAAQ,CAAAoB,MAAb,EAAqB;YACpBd,aAAa,GAAGD,eAAe,GAAGC,aAAlC,CAAAW,KAAA,CAAAT,KAAA,GAAAtC,MAAA;YACAmC,eAAA;UA9DF;;YAiEIC,aAAY,GAAhBA,aAAwB,CAAAW,KAAA,CAAAT,KAAA,IAAAtC,MAAA,IAAAhB,KAAA,CAAAgB,MAAA;UACvB;QACA;;;QAKF,KAAA8B,OAAA,CAAAoB,MAAA;UACDd,aAAA,GAAAD,eAAA,GAAAC,aAAA;QACA;;MACC,IAAAR,YAAe;QACd,OAAKuB,MAAA;MACJ;;;IAID;AACC;AACA;EAFD;IAAA3E,GAAA;IAAAC,KAAA,EAKA,SAAAuD,eAAIC,YAAA,EAAsBmB,WAAY;MACrC,KAAAnB,YAAO,CAAAoB,OAAa,KAAbD,WAA+B,CAAAC,OAAA,EAAW;QACjD;;;MAIA,IAjByEpB,YAAA,CAAAQ,IAAA;;;;MAsBzE,IAtByER,YAAA,CAAAqB,QAAA,CAAAtD,MAAA;;;MA0BzE,IAAAiC,YAAA,CAAAsB,OAAA,CAAAvD,MAAA,QAAAiC,YAAA,CAAAsB,OAAA,CAAAC,QAAA,CAAAJ,WAAA,CAAAC,OAAA;QA1ByE;;;MA+B1E,IAAAD,WAAA,CAAAK,MAAA,CAAAzD,MAAA;QAED,OAAAoD,WAAA,CAAAK,MAAA,CAAAD,QAAA,CAAAvB,YAAA,CAAAoB,OAAA;MACD;;MAGA,KAAApB,YAAA,CAAAyB,IAAA,IAAAzB,YAAA,CAAAoB,OAAA,KAAAD,WAAA,CAAAC,OAAA;;;;MAEU,OAAAM,OAAF,CAAA1B,YAAA,IAAAA,YAAA,CAAA2B,OAAA,GAAAR,WAAA,CAAAS,IAAA;IAAU;IAAV;;AAEN;AACC;AACA;EAJK;IAAArF,GAAA;IAAAC,KAAA,EAON,SAAAqF,kBAAchE,MAAG,EAAO;wBAMxB,KAAAC,KAAa;QAHbgE,MAAA,GAAAC,WAAA,CAAAD,MAAA;;MAMA,IAAAA,MAAA,IAAAE,iBAAA,IAAAnE,MAAA,CAAAd,KAAA;QAED,OAAAc,MAAA;MACD;;MAGA,IAAAoE,UAAA,GAAApE,MAAA,CAAAqE,OAAA;;;;MAEED,UAAM,GAAOA,UACJ,CAAAC,OAAP,MAAkB,SAAlB;MACF,OAAMD,UAAM;;IAEZ;AACC;AACA;;AAED;EAJA;IAAA1F,GAAA;IAAAC,KAAA,EAOA,SAAAkC,gBAAWb,MAAM;MAChB,IAAAsE,qBAAa;MAEZ,IAAAC,OAAA,UAAAC,MAAA,oBAAAA,MAAA,CAAAC,uBAAA,IAAAhF,cAAA;MACD,IAJDiF,GAIO,GAAAH,OAAA;MAEN,KAAAG,GAAA;;MAED;MAGD,IAAAC,GAAA,IAAAL,qBAAA,QAAArE,KAAA,CAAA2E,gBAAA,cAAAN,qBAAA,cAAAA,qBAAA;MACD,IAAAO,EAAA,GAAAF,GAAA,eAAAA,GAAA,kBAAAD,GAAA,CAAAI,IAAA,GAAAJ,GAAA,CAAAK,aAAA,CAAAJ,GAAA;MAEA,IAAA3E,MAAA,CAAAd,KAAA,CAAAK,aAAA;;;QACC;MACC,OAAM;QAAEsF,EAAA,CAAAG,SAAA,QAAAhB,iBAAA,MAAA/D,KAAA,CAAAgF,UAAA,GAAAA,UAAA,CAAAjF,MAAA,IAAAA,MAAA;MAAF;MAEN,OAAI6E,EAAK;;IAET;AACC;AACA;;EAFD;IAAAnG,GAAA;IAAAC,KAAA,EAMC,SAAAuG,kBAAMvD,IAAA;MAAA,IAAAwD,MAAA;MAAE,IAAMC,eAAA,GAAR,IAAkB,CAAAnF,KAAxB,CAAcmF,eAAA;MACd,IAAAC,UAAa,GAAG;MAChB,IAAAC,KAAM;MAGN,IAAA3D,IAAK,CAAA4D,QAAK,KAAOlG,YAAO,KAAAsC,IAAA,CAAA0D,UAAA;QACvB;MACA;;;QAID,IAMCxG,IAAA,G,KAAAA,IAAA;UAlB2CF,KAAA,G,KAAAA,KAAA;;QAsB5C,IAAI8C,MAAwB,GAAG+D,UAAO,CAAAC,OAAK,CAAZ,IAAsBD,UAAK,CAAA3G,IAAA;;QAG1D,IAAI,CAAAsG,MAAA,CAAMO,MAAK,CAAA/D,IAAA;UACd;QAGA,CAJD;QAKC;;QAKA,KAAA8D,OAAA,CAAAvG,KAAA,CAAAM,aAAA,OAAA4F,eAAA,MAAA3D,MAAA,IAAAA,MAAA,KAAAkE,WAAA,KAAAF,OAAA,CAAAG,UAAA,UAAAjH,KAAA,CAAA0F,OAAA,6BAAAnF,KAAA;;QAED;;;;QAQA,IAAAuC,MAAO,KAAPoE,gBAAA;UACAC,QAAA;;UAEDA,QAAO,GAAAC,MAAP,CAAAC,UAAA,CAAA/G,MAAA,CAAA6G,QAAA;QACA,WAAArE,MAAA,KAAAwE,cAAA;UAEDH,QAAA,GAAA7G,MAAA,CAAA6G,QAAA;QACD;;;MAEC;;QAIC,OAAM,IAAK;MACV;MAEA,OAAIT,UAAO;IACV;IACA;AACD;AAED;EAHE;IAAA3G,GAAA;IAAAC,KAAA,EAOJ,SAAAuH,sBAAAvE,IAAA;MACA,IAAAwE,MAAA;;;QACC,IAAAxH,KAAa,GAAAgD,IAA6B,CAAAyE,KAAA,CAAA1H,GAAA;QAExC,WAAUC,KADI,wBAAAA,KAAA;UAEdwH,MAAO,CAAEzH,GAFK,CAAA2F,OAAA,wBAAAnF,KAAA,EAAAmH,MAAA;YAAA,OAAApH,MAAA,CAAAoH,MAAA,EAAAC,WAAA;UAAA,MAAA3H,KAAA;QAGd;MACA;MACA,OAAIwH,MALU;IAMd;IACA;AACA;AARc;EAOd;IAAAzH,GAAA;IAAAC,KAAA,E;MAOD,IAAI4H,MAAK;QACR/C,QAAO,EACN,EAAG;QACHM,OAAG,EAAI,CAAC;QACRL,OAAA;QAHME,MAAP;QAKAC,IAAA;;QAEDG,IAAA,EAAO;QACPpB,IAAA;MAED;MACD;MACA;;;QACC,OAAAQ,aAAA,CAAAA,aAAA,CAAAA,aAAA,KAAmCoD,MAAA,GAClCC,IAAA,CAAAjD,OAAA;UACIA,OAAO,EAAPA;QAAO;MAIV;MACA,OAAIgD,MAAM;IACT;IACA;;AAED;EAFC;IAAA7H,GAAA;IAAAC,KAAA,E;MAaF;MACA,WAAA8H,iBAAA,oBAAA9E,IAAA,YAAA8E,iBAAA;QAED,IAAAC,IAAA,GAAA/E,IAAA,CAAAgF,YAAA;QACD;;;;QAEC;QAEE,IAAAC,QAAA,GAAAjF,IAAA,CAAAiF,QAAA,CAAAC,WAAA;QAFqC,OAAAD,QAAA,YAAAA,QAAA,gBAAAA,QAAA,iBAAAA,QAAA,kBAAAA,QAAA;;MAMtC,OAAO;IACP;IAED;AACD;AACA;EAFC;IAAAlI,GAAA;IAAAC,KAAA,E;;QAKA,OAAgB;MACf;;;IAIA;IACA;AAED;AACD;AACA;AACA;EALE;IAAAD,GAAA;IAAAC,KAAA,EAMD,SAAAmI,MAAA;MACC,SAAM,CAAAlG,SAAA;QACL,OADK;MAEL;MAEA,WAJK,CAAAmG,SAAA,MAAAnG,SAAA,OAAAoG,YAAA,MAAApG,SAAA,CAAAqG,QAAA,CAAAJ,WAAA;IAKL;IALK;AAON;AACA;;EARM;IAAAnI,GAAA;IAAAC,KAAA,EAaL,SAAAoI,UAAIG,UAAK,EAAL/E,YAAkB;MAAA,IAAAgF,MAAA;MACrB,IAAAC,YAAA,GAOC,IARkC,CAAAnH,KAAA;QAEnCgE,MAAA,GAAAmD,YAAA,CAAAnD,MAAA;;QAGAoD,aAAI,GAAAD,YAAA,CAAJC,aAAI;QACHC,SAAA,GAAAF,YAAA,CAAAE,SAAA;QACAC,sBAAA,GAAAH,YAAA,CAAAG,sBAAA;;;;;QAMD;QACC,IAAA5F,IAAA,CAAA4D,QAAA,KAAAlG,YAAA;UACA,IAfkCkE,OAAA,GAAA5B,IAAA,CAAAsF,QAAA,CAAAJ,WAAA;;;UAkBnC,IAAIW,UAAJ;;YAEAA,UAAI,GAAS,EAAI;UAChB;;UAIA,IAAA5F,QAAW,GAAAuF,MAAK,CAAAzF,gBAAoB,CAAA6B,OAApC,EAAA5B,IAAA;;YAIA;UACC;;UAED,IAAA6B,QAAI;UAC2E,IAAA8D,SAAA,MAAAC,sBAAA,KAAAJ,MAAA,CAAAM,YAAA,CAAAlE,OAAA;YAAF4D,MAA5E,CAAAxG,QAAA;YAEA,IAAAjC,GAAA,GAAAyI,MAAA,CAAAxG,QAAA;;;;YAnCiC,IAAA+G,WAAA;;;YA4ClC,WAAAA,WAAA;cA5CkC5D,OAAA,CAAA6D,IAAA,eAAAC,KAAA,CAAAC,YAAA,CAAAH,WAAA;gBAgDnChJ,GAAA,EAAAA;cACA;cACA;;;YAMCyI,MAAA,CAAKxG,QAAL,GAAAjC,GADC;;;UAMA,IAAAyI,MAAA,CAAAjG,MAAA,CAAA4G,GAAA,CAAAvE,OAAA;YADkC;;UAInC;UACC;UACA;;UAGA,MAAAU,MAAA,IAAY8D,oBAAoB,IAAhCxE,OAAA,cAAA4D,MAAA,CAAAM,YAAA,CAAAlE,OAAA,MAAA8D,aAAA,IAAAF,MAAA,CAAAjF,cAAA,CAAAC,YAAA,EAAAC,MAAA;YACA,IAAA4F,SAAA;YAEDb,MAAA,CAAAxG,QAAA;;YAGE,IACA0E,UAAY,GAAA8B,MAAK,CAAAjC,iBAAoB,CAAAtD,QArBtC;YA0BD,IAAAqG,YAAA;cACA1E,OAAA,EAAAA;YA/BD;YAnDmC,IAAA8B,UAAA;;YAApC;YAgGK,IAAKjD,MAAA,CAAAO,IAAA,EAAc;;YAEvB;YAAAmB,OAEO,CAAA6D,IAAA,eAAAC,KAAA,CAAA7C,aAAA,CAAAmD,OAAA,EAAA/E,aAAA,CAAAA,aAAA,KAAA8E,YAAA;cACNvJ,GAAA,EAAAyI,MAAU,CAAAxG;YAAV,IACA,CAAAqH,SAAA,GAAAxE,QAAA,cAAAwE,SAAA,cAAAA,SAAA,GAAAb,MAAA,CAAAJ,SAAA,CAAAnF,QAAA,EAAAQ,MAAA;YACD;YAzGF;;YA4GI0B,OAAA,MAAAZ,MAAA,CAAAiF,kBAAA,CAAYrE,OAAA,GAAAqE,kBAAA,CAAAhB,MAAA,CAAAJ,SAAA,CAAAnF,QAAA,EAAAQ,MAAA,CAAAmB,OAAA,GAAAnB,MAAA,GAAAD,YAAA;UACf;;UAGD,IAAOiG,IAAP,GAAAnE,MAAA,KAAA8D,oBAAA,GAAApG,IAAA,CAAA0G,WAAA;UAAA;UACAlB,MAAA,CAAAmB,aAAA,CAAA3G,IAAA,CAAA0G,WAAA,QAAAlG,YAAA;UAGF,IAAAoG,KAAA,CAAAC,OAAA,CAAAJ,IAAA;YACAtE,OAAA,MAAAZ,MAAA,CAAAiF,kBAAA,CAAArE,OAAA,GAAAqE,kBAAA,CAAAC,IAAA;UACA;;;QACC;MACC;MAEC,IAAAZ,UAAA;;MAED;MAEA,OAAI1D,OAAgC;;IAGpC;AACC;AACA;AACA;EAHD;IAAApF,GAAA;IAAAC,KAAA,EAME,SAAA8J,cAAMpG,eAAW,EAAAR,QAAS,EAAU;MACpC,IAPsC,CAAAQ,eAAA,CAAAqB,QAAA;;;MAWtC,IAAAgF,KAAM,GAAN,EAAW;;MAGX,IAAAC,IAAI,GAAG,IAAI,CAAC;;;QAGb,IAAAC,KAAA,GAAMD,IAAA;UAAAE,MAAA,GAAAC,cAAA,CAAAF,KAAA;UAAA1J,KAAA,GAAA2J,MAAA;UAAA9F,SAAA,GAAA8F,MAAA;QAAE,IAAAE,UAAF,GAAAJ,IAAA,CAAAnG,KAAA;QAAY,IAAAE,MAAZ,GAAAxD,KAAA,CAAAwE,QAAA;QAAA,IAA6CnD,OAAA,CAAQC,GAAC,CAAAC,QAA5D,sBAAAoB,QAAA,CAAAkB,SAAA;UACA,MAAI,IAAJiG,KAlBuC,YAAA9F,MAAA,CAAAH,SAAA;;;QAwBtC,IAAAgG,UAAW,MAAO;UAHnBL,KAMO,CAAAf,IAAA,CAAAS,IAAA,CAAAnF,KAAA,IAAA8F,UAAA;;;QAGN;QAEC,IAAAE,mBAAA,GAhCqCpH,QAAA,CAAAkB,SAAA;;UAkCtCf,OAAA,GAAAiH,mBAAA,CAAAjH,OAAA;UAEMiG,YACG,GAAAgB,mBAAA,CADThJ,KAAK;;;QASN,IAAIyC,MAAG,EAAK;UAvDqEwG,QAAA,GAAAhK,KAAA,CAAAgB,MAAA;;;UA2D9E,IAAKiJ,KAAL,GAAcf,IAAG,CAAAlJ,KAAA,KAAAkK,MAAA,QAAAlG,MAAA,CAAAH,SAAA;UA3D6D,IAAAxC,OAAA,CAAAC,GAAA,CAAAC,QAAA,sBAAA0I,KAAA;;;UAiEjFD,QAAA,GAAAC,KAAA,CAAA3G,KAAA,GAAA2G,KAAA,IAAAjJ,MAAA;UACAwI,KAAA,CAAAf,IAAA,CAAA3F,OAAA,CAAA+C,aAAA,MAAA0D,aAAA,CAAAL,IAAA,CAAAnF,KAAA,CAAA/D,KAAA,CAAAgB,MAAA,EAAAiJ,KAAA,CAAA3G,KAAA,GAAAX,QAAA,GAAAoG,YAAA;;;QAGAG,IAAA,GAAAA,IAAA,CAAAnF,KAAA,CAAAiG,QAAA;;;;QAlmBiBR,KAAA,CAAAf,IAAA,CAAAS,IAAA;;;MCtCnB,IAAMM,KAAA,CAAAxI,MAAA;QACL,SADK;MAEL;MAEA,IAAAwI,KAJK,CAAAxI,MAAA,iBAAAwI,KAAA;QAKL,OAAAA,KALK;MAML;MAEA,OAAMA,KAAE;IARH;EAAA;EAAA,OAAA3I,MAAA;AAAA;AAYN;AAGC,SAAAsJ,MAAWC,CAAArJ,KAAG;EACd,IAFDsJ,IAEO;MAGNlE,UAAU,G,MAAVA,UAAU;IACTmE,SAAA,G,MAAAA,SAAA;IACA5E,gBAAA,G,MAAAA,gBAAA;IACDd,OAAA,G,MAAAA,OAAA;;IAED2F,aAAK,G,MAALA,aAAK;IACJlG,OAAA,G,MAAAA,OAAA;IACAmG,UAAA,G,MAAAC,MAAA;EAED,IAAIhF,GAAA,GAAQ,CAAA4E,IAAA,GAAA3E,gBAAA,aAAAA,gBAAA,cAAAA,gBAAA,GAAArB,OAAA,cAAAgG,IAAA,cAAAA,IAAA;EACX,IAAAI,MAAA,GAAAhF,GAAA,yBAAA+E,UAAA;EACA,IAAAJ,WAAA;;IAGDA,WAAA,GAAAG,aACC;EAAS;IAAwB,IAAAzJ,MAAW,OAAAD,MAA5C,CAAA+D,OAAA,aAAAA,OAAA,cAAAA,OAAA,OAAA7D,KAAA,EAAA6G,KAAA;IAAA,IACE9G,MAAA,CAAAE,MAFH;MAKAoJ,WAAA,GAAAtJ,MAAA;;EC9CD;EAOC,KAAAsJ,WAAM;IACLA,WADK,GAAAM,YAAA;EAEL;EAEA,IAAAD,MAAA;IACA;IACA,oBANK/B,KAAA,CAAA7C,aAAA,CAAA6C,KAAA,CAAAiC,QAAA,QAAAP,WAAA;EAOL;EAEA,oBAAe1B,KATV,CAAA7C,aAAA,CAAAmD,OAAA;IAUL7C,UAAA,EAAAA,UAVK;IAWLmE,SAAO,EAAGA,SAXL;IAYLjG,OAAM,EAAGoB;EACT,GAAA2E,WAAG;AAbE;AAeN;;AAGA,SAAMQ,WAAA7J,KAAiB;MAGvBoF,UAAY,GAcXpF,KAAI,CAdLoF,UAAY;IACXmE,SAAI,GAaJvJ,KAAI,CAbJuJ,SAAI;IAAAO,cAAA,GAaJ9J,KAAI,CAZH6D,OAAA;IAAAA,OAAA,GAAAiG,cAAA,mBAAAA,cAAA;IAAAC,qBAAA,GAYD/J,KAAI,CAXHgK,cAAA;IAAAA,cAAA,GAAAD,qBAAA,sBAAAA,qBAAA;IAAAE,qBAAA,GAWDjK,KAAI,C;;0BAAJA,KAAI,CATJ2J,YAAY;IAAZA,YAAY,GAAAO,mBAAA,qBAAAA,mBAAA;IAAAC,cAAA,GASZnK,KAAI,CARHG,OAAA;IAAAA,OAAA,GAAAgK,cAAA,mBAAAA,cAAA;IAAAC,eAAA,GAQDpK,KAAI,CAPHE,QAAA;IAAAA,QAAA,GAAAkK,eAAA,mBAAAA,eAAA;IAAAC,mBAAA,GAODrK,KAAI,CAdLsK,YAtBkD;IAsBlDA,YAtBkD,GAAAD,mBAAA,qBAAAA,mBAAA;IAAAE,oBAAA,GAoCjDvK,KAAI,C;;qBAAJA,KAAI,CAHLsD,OAAM;IAANA,OAAM,GAAAkH,cAAA,cAAM,MAAG,GAAAA,cAAA;IAAAC,aAAA,GAGdzK,KAAI,CAFJ0J,MAAM;IAANA,MAAM,GAAAe,aAAA,sBAAAA,aAAA;2CAENzK,KAAI,EAAA0K,UAAA;EACH,IAAAC,WAAU,GAAAC,eAAU,QAAA1K,QAAA;EACpB,IAAA2K,UAAA,GAAAb,cAAA,QAAA7J,OAAA;;EAED,IAAA2K,cAAA,GAAAR,YAAA,IAAAA,YAAA;;;IAID,IAAMvI,OAAM,CAAAgJ,aAAc;;IAG1B;;MAGCD,cAAgB,CAAApD,IAAK,CAAC3F,OAAN,CAAcuI,YAAY,CAAAU,IAAA,CAAAjJ,OAAA;IACzC;EAGA;;EAED,IAAAhC,MAAO,GAAAkL,eAAP,CAAA3J,MAAA,WAAA8B,MAAA,EAAA8H,QAAA;IATa,IAUXC,UAVH,GAAAD,QAAA,CAAA9H,MAAA,EAAApD,KAAA;IAcE,IAAAM,OAAU,CAAEC,GAAA,CAAAC,QADb,4BAAA2K,UAAA;MAEC,UAAW1K,SAFZ;IAAA;IAKC,OAAA0K,UAAc;EACd,GAAAtH,OAAQ,SANT,IAAAA,OAAA,cAAAA,OAAA;;EAQC,IAAAuH,MAAS,OAAAtL,MAAA,CAAAC,MAAA,EAAAsL,WAAA,EAAAV,WAAA,EAAAE,UAAA;;EAGX,IAAApC,KAAA,GAAAqC,cAAA,CAAAxJ,MAAA,WAAAgK,WAAA,EAAAJ,QAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}